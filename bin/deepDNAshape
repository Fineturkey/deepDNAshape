#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
from deepDNAshape import predictor


if __name__ == "__main__":
    os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
    import argparse, sys
    programname = sys.argv[0]
    parser = argparse.ArgumentParser(description='Predict DNA shapes for any sequences. Input can be one single sequence or a FILE containing multiple sequences.\n\nFILE format: \nSEQ1\nSEQ2\nSEQ3\n...\n\nExamples:\npython '+programname+' --seq AAGGTAGT --feature MGW\
        \npython '+programname+'.py --file seq.txt --feature Roll --output seq_Roll.txt', formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument("--feature", dest = "feature", default = "MGW", help = "Specify which DNA shape feature to be predicted. [Default is MGW (minor groove width), other options: Shear, Stretch, Stagger, Buckle, ProT, Opening, Shift, Slide, Rise, Tilt, Roll, HelT]. Use FEATURE-FL to predict fluctuation values.")
    parser.add_argument("--seq", dest = "seq", help = "Specify the sequence to be predicted.")
    parser.add_argument("--file",dest = "file", help = "If no --seq is provided, use --file to read in all sequences.")
    parser.add_argument("--layer", default=4, dest = "layer", type = int, help = "Select output layer number (0 to 7). Choose bigger number if you want to evaluate longer range effects from flanking regions. Don't change this parameter if you are not sure. [Default is 4].")
    parser.add_argument("--output", dest = "output", default = "stdout", help = "Specify where the predictions will be written to. [Defualt is stdout]")
    parser.add_argument("--batch_size", dest = "batch_size", default=2048, type = int, help = "If --file is provided, use this parameter to adjust parallel computing maximum. [Default is 2048] use higher values to speed up your prediction subject to your CPU/mem resources.")
    parser.add_argument("--gpu", dest = "gpu", help = "Use --gpu if you have available GPUs, and are predicting a file, make sure CUDA, CuDNN are installed correctly.")
    args = parser.parse_args()

    myPredictor = predictor.predictor()
    if args.seq:
        prediction = list(map(str, myPredictor.predict(args.feature, args.seq, args.layer)))
        print(args.seq + " " + " ".join(prediction))
    elif args.file:
        if args.output == "stdout":
            usefile = False
            fout = sys.stdout
        else:
            usefile = True
            fout = open(args.output, "w")
        with open(args.file) as fin:
            seqBatch = []
            for seq in fin:
                seqBatch.append(seq.strip())
                if len(seqBatch) == args.batch_size:
                    prediction = myPredictor.predictBatch(args.feature, seqBatch, args.layer)
                    fout.write(prediction.shape)
                    for i, seq in enumerate(seqBatch):
                        fout.write(seq + " " + " ".join(list(map(str, prediction[i]))) + "\n")
                    seqBatch = []
            if seqBatch != []:
                prediction = myPredictor.predictBatch(args.feature, seqBatch, args.layer)
                for i, seq in enumerate(seqBatch):
                    fout.write(seq + " " + " ".join(list(map(str, prediction[i]))) + "\n")
        if usefile:
            fout.close()
    else:
        parser.print_help(sys.stderr)
        sys.exit(1)
